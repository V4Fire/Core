<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>&quot;src/core/data/index&quot; | V4Fire</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="../assets/css/main.css">
<style>/*!
 * V4Fire Core
 * https://github.com/V4Fire/Core
 *
 * Released under the MIT license
 * https://github.com/V4Fire/Core/blob/master/LICENSE
 */

.tsd-panel {
	border: 1px solid #DDD;
	border-radius: 10px;
	box-shadow: none;
}

.tsd-page-title {
	color: #EEE;

	background: #232526;  /* fallback for old browsers */
	background: -webkit-linear-gradient(to right, #414345, #232526);  /* Chrome 10-25, Safari 5.1-6 */
	background: linear-gradient(to right, #414345, #232526); /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */
}

.tsd-page-toolbar {
	height: 43px;
}

.title {
	display: inline-flex;
	align-items: center;
}

.title::before {
	content: "";

	display: inline-block;
	width: 20px;
	height: 20px;
	margin-right: 10px;

	border-radius: 5px;
	background-image: url("https://avatars0.githubusercontent.com/u/29952525?s=200&v=4");
	background-size: contain;
}

#tsd-search .tsd-widget.search.no-caption {
	bottom: 0;
}

#tsd-search .field {
	height: 100%;
}
</style>
</head>
<body>
<script>'use strict';

/*!
 * V4Fire Core
 * https://github.com/V4Fire/Core
 *
 * Released under the MIT license
 * https://github.com/V4Fire/Core/blob/master/LICENSE
 */

/* eslint-disable prefer-arrow-callback, no-var */

(function () {
	if (localStorage.getItem('visibility') == null) {
		localStorage.setItem('visibility', 'public');
	}

	document.title = document.title.replace(/['"]+|src\//g, '');
	document.body.style.display = 'none';
})();
</script>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="../assets/js/search.js" data-base="..">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="../index.html" class="title">V4Fire</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<div class="tsd-select" id="tsd-filter-visibility">
								<span class="tsd-select-label">All</span>
								<ul class="tsd-select-list">
									<li data-value="public">Public</li>
									<li data-value="protected">Public/Protected</li>
									<li data-value="private" class="selected">All</li>
								</ul>
							</div>
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="../globals.html">Globals</a>
				</li>
				<li>
					<a href="src_core_data_index.html">&quot;src/core/data/index&quot;</a>
				</li>
			</ul>
			<h1>External module &quot;src/core/data/index&quot;</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<section class="tsd-panel tsd-comment">
				<div class="tsd-comment tsd-typography">
					<div class="lead">
						<a href="#coredata" id="coredata" style="color: inherit; text-decoration: none;">
							<h1>core/data</h1>
						</a>
						<p>This module provides API to create an abstraction under data — a data provider.
						The provider grants methods to access and modify data that is represented as one logical instance.</p>
						<p>For example, we need to create API for a user in our application. Let&#39;s start with a simple REST architecture:</p>
						<ol>
							<li><code>GET user/:id</code> returns an object of user fields by the specified user id:</li>
						</ol>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'core/request'</span>;
request(<span class="hljs-string">'user/1'</span>);</code></pre>
						<pre><code class="language-json">{
  <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Andrey"</span>,
  <span class="hljs-attr">"age"</span>: <span class="hljs-number">30</span>
}</code></pre>
						<ol start="2">
							<li><code>PUT user/:id</code> modifies a user by the specified id with some provided data and returns new data:</li>
						</ol>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'core/request'</span>;
request(<span class="hljs-string">'user/1'</span>, {<span class="hljs-attr">method</span>: <span class="hljs-string">'PUT'</span>, <span class="hljs-attr">body</span>: {<span class="hljs-string">"age"</span>: <span class="hljs-number">31</span>}});</code></pre>
						<pre><code class="language-json">{
  <span class="hljs-attr">"id"</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Andrey"</span>,
  <span class="hljs-attr">"age"</span>: <span class="hljs-number">31</span>
}</code></pre>
						<ol start="3">
							<li><code>DELETE user/:id</code> deletes a user by the specified id:</li>
						</ol>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'core/request'</span>;
request(<span class="hljs-string">'user/1'</span>, {<span class="hljs-attr">method</span>: <span class="hljs-string">'DELETE'</span>});</code></pre>
						<ol start="4">
							<li><code>POST user</code> creates a new user with the specified data and returns it:</li>
						</ol>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'core/request'</span>;
request(<span class="hljs-string">'user'</span>, {<span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, <span class="hljs-attr">body</span>: {<span class="hljs-string">"name"</span>: <span class="hljs-string">"Andrey"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-number">30</span>}});</code></pre>
						<pre><code class="language-json">{
  <span class="hljs-attr">"id"</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">"name"</span>: <span class="hljs-string">"Andrey"</span>,
  <span class="hljs-attr">"age"</span>: <span class="hljs-number">30</span>
}</code></pre>
						<p>All of these handlers are associated with one data model that represents a user. Knowing this, we can create a class for this model.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'core/request'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  url = <span class="hljs-string">'user/'</span>;

  <span class="hljs-keyword">async</span> <span class="hljs-keyword">get</span>(id) {
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> request(<span class="hljs-keyword">this</span>.url + id)).data;
  }

  <span class="hljs-keyword">async</span> upd(id, body) {
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> request(<span class="hljs-keyword">this</span>.url + id, {<span class="hljs-attr">method</span>: <span class="hljs-string">'PUT'</span>, body})).data;
  }

  <span class="hljs-keyword">async</span> del(id) {
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> request(<span class="hljs-keyword">this</span>.url + id, {<span class="hljs-attr">method</span>: <span class="hljs-string">'DELETE'</span>})).data;
  }

  <span class="hljs-keyword">async</span> add(body) {
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> request(<span class="hljs-keyword">this</span>.url, {<span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, body})).data;
  }
}</code></pre>
						<p>This might seem naive, but it works. Also, we need to create some API to submit events of the provider that allows notifying an application if data was changed.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'core/request'</span>;
<span class="hljs-keyword">import</span> { EventEmitter2 <span class="hljs-keyword">as</span> EventEmitter } <span class="hljs-keyword">from</span> <span class="hljs-string">'eventemitter2'</span>;

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{
  url = <span class="hljs-string">'user/'</span>;
  emitter = <span class="hljs-keyword">new</span> EventEmitter();

  <span class="hljs-keyword">async</span> <span class="hljs-keyword">get</span>(id) {
    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">await</span> request(<span class="hljs-keyword">this</span>.url + id)).data;
  }

  <span class="hljs-keyword">async</span> upd(id, body) {
    <span class="hljs-keyword">const</span> {data} = <span class="hljs-keyword">await</span> request(<span class="hljs-keyword">this</span>.url + id, {<span class="hljs-attr">method</span>: <span class="hljs-string">'PUT'</span>, body});
    <span class="hljs-keyword">this</span>.emitter.emit(<span class="hljs-string">'upd'</span>, data);
    <span class="hljs-keyword">return</span> data;
  }

  <span class="hljs-keyword">async</span> del(id) {
    <span class="hljs-keyword">const</span> {data} = <span class="hljs-keyword">await</span> request(<span class="hljs-keyword">this</span>.url + id, {<span class="hljs-attr">method</span>: <span class="hljs-string">'DELETE'</span>});
    <span class="hljs-keyword">this</span>.emitter.emit(<span class="hljs-string">'del'</span>, data);
    <span class="hljs-keyword">return</span> data;
  }

  <span class="hljs-keyword">async</span> add(body) {
    <span class="hljs-keyword">const</span> {data} = <span class="hljs-keyword">await</span> request(<span class="hljs-keyword">this</span>.url, {<span class="hljs-attr">method</span>: <span class="hljs-string">'POST'</span>, body});
    <span class="hljs-keyword">this</span>.emitter.emit(<span class="hljs-string">'add'</span>, data);
    <span class="hljs-keyword">return</span> data;
  }
}</code></pre>
						<p>Still looks fine and useful, but if we want to create more classes for other data instances we need to create some kind of superclass to avoid &quot;copy-pasting&quot; code lines. Also, the superclass may improve our API with added extra functionality, such as support for socket events, middlewares, etc. And this is exactly what &quot;core/data&quot; module does.</p>
						<a href="#default-interface" id="default-interface" style="color: inherit; text-decoration: none;">
							<h2>Default interface</h2>
						</a>
						<p>The &quot;core/data&quot; module provides a default interface for any data providers. If your class implements this interface, then you can use it as a data provider with any V4Fire modules. This interface is pretty similar to the above-mentioned example of a data class but realizes more common API. Let&#39;s take a look at it.</p>
						<p><strong>core/data/interface</strong></p>
						<pre><code class="language-ts"><span class="hljs-keyword">import</span> { EventEmitterLike } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/async'</span>;
<span class="hljs-keyword">import</span> {

  CreateRequestOptions,
  RequestQuery,
  RequestMethod,
  RequestResponse,
  RequestBody

} <span class="hljs-keyword">from</span> <span class="hljs-string">'core/request'</span>;

<span class="hljs-keyword">import</span> { ModelMethod } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/data/interface'</span>;
<span class="hljs-keyword">export</span> * <span class="hljs-keyword">from</span> <span class="hljs-string">'core/data/interface/types'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">interface</span> Provider {
  readonly providerName: <span class="hljs-built_in">string</span>;

  readonly emitter: EventEmitterLike;

  name(): CanUndef&lt;ModelMethod&gt;;
  name(value: ModelMethod): Provider;

  method(): CanUndef&lt;RequestMethod&gt;;
  method(value: RequestMethod): Provider;

  base(): <span class="hljs-built_in">string</span>;
  base(value: <span class="hljs-built_in">string</span>): Provider;

  url(): <span class="hljs-built_in">string</span>;
  url(value: <span class="hljs-built_in">string</span>): Provider;

  dropCache(): <span class="hljs-built_in">void</span>;

  <span class="hljs-keyword">get</span>&lt;T = unknown&gt;(query?: RequestQuery, opts?: CreateRequestOptions&lt;T&gt;): RequestResponse;

  peek&lt;T = unknown&gt;(query?: RequestQuery, opts?: CreateRequestOptions&lt;T&gt;): RequestResponse;

  post&lt;T = unknown&gt;(body?: RequestBody, opts?: CreateRequestOptions&lt;T&gt;): RequestResponse;

  add&lt;T = unknown&gt;(body?: RequestBody, opts?: CreateRequestOptions&lt;T&gt;): RequestResponse;

  upd&lt;T = unknown&gt;(body?: RequestBody, opts?: CreateRequestOptions&lt;T&gt;): RequestResponse ;

  del&lt;T = unknown&gt;(body?: RequestBody, opts?: CreateRequestOptions&lt;T&gt;): RequestResponse;
}</code></pre>
						<p>Many of these methods look familiar, but we also have some new method and properties:</p>
						<ol>
							<li><code>providerName</code> contains a full name of the provider.</li>
							<li><code>name</code> — a pair of get/set methods to provide &quot;logical&quot; meaning for a request:</li>
						</ol>
						<pre><code class="language-js"><span class="hljs-comment">// Will emit "init" event, which contains the data, after successfully receiving</span>
myProvider.name(<span class="hljs-string">'init'</span>).get(<span class="hljs-string">'foo'</span>);</code></pre>
						<p>Mind that the default V4Fire implementation of a data provider by default sends events for &quot;upd&quot;, &quot;add&quot;, &quot;del&quot; requests.
						These events have the same name with methods that produce them.</p>
						<ol start="3">
							<li><code>method</code> — a pair of get/set methods to provide a type of HTTP request:</li>
						</ol>
						<pre><code class="language-js"><span class="hljs-comment">// The request uses POST method to get data</span>
myProvider.method(<span class="hljs-string">'POST'</span>).get(<span class="hljs-string">'foo'</span>);</code></pre>
						<ol start="4">
							<li><code>base</code> — a pair of get/set methods to provide a base URL for requests:</li>
						</ol>
						<pre><code class="language-js"><span class="hljs-comment">// The request is addressed for https://google.com/foo</span>
myProvider.base(<span class="hljs-string">'https://google.com'</span>).get(<span class="hljs-string">'foo'</span>);</code></pre>
						<ol start="5">
							<li><code>url</code> — a pair of get/set methods to provide URL for requests:</li>
						</ol>
						<pre><code class="language-js"><span class="hljs-comment">// The request is addressed for https://google.com/foo</span>
myProvider.url(<span class="hljs-string">'https://google.com'</span>).get(<span class="hljs-string">'foo'</span>);

<span class="hljs-comment">// We can combine .base() and .url():</span>
<span class="hljs-comment">// The request is addressed for https://google.com/bla/baz</span>
myProvider.base(<span class="hljs-string">'https://google.com'</span>).url(<span class="hljs-string">'bla/baz'</span>).get(<span class="hljs-string">'foo'</span>);</code></pre>
						<ol start="6">
							<li><p><code>dropCache</code> — a method that drops any request cache.</p>
							</li>
							<li><p><code>peek</code> — a request that logically is similar to the checking of API accessibility, it uses HEAD by default.</p>
							</li>
							<li><p><code>post</code> — a request that sends to a server some data without any logical representation, it uses POST by default.</p>
							</li>
						</ol>
						<a href="#default-implementation" id="default-implementation" style="color: inherit; text-decoration: none;">
							<h2>Default implementation</h2>
						</a>
						<p>In addition to the base interface of data providers V4Fire provides an implementation that grants some extra functionality and more flexibility.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  baseURL = <span class="hljs-string">'user/:id'</span>;
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User();
user.get({<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>}).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(data);
})</code></pre>
						<a href="#constructor-parameters" id="constructor-parameters" style="color: inherit; text-decoration: none;">
							<h3>Constructor parameters</h3>
						</a>
						<p>You can provide some parameters to a provider by using a constructor.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  baseURL = <span class="hljs-string">'user/:id'</span>;
}

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> User({
  <span class="hljs-attr">externalRequest</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">socket</span>: <span class="hljs-literal">true</span>
});</code></pre>
						<p>The entire list of parameters:</p>
						<pre><code class="language-ts"><span class="hljs-keyword">interface</span> ProviderOptions {
  <span class="hljs-comment">/**
   * List of additional data providers for the "get" method.
   * It can be useful if you have some providers that you want combine to one.
   */</span>
  extraProviders?: FunctionalExtraProviders;

  <span class="hljs-comment">/**
   * Provider alias: it is used with extra providers
   */</span>
  alias?: <span class="hljs-built_in">string</span>;

  <span class="hljs-comment">/**
   * If true, then all emitting events, which is emitted by the provider,
   * that have a similar hash will be collapsed to one
   *
   * @default `false`
   */</span>
  collapseEvents?: <span class="hljs-built_in">boolean</span>;

  <span class="hljs-comment">/**
   * @see &lt;a href="../interfaces/src_core_request_interface.createrequestoptions.html#externalrequest"&gt;CreateRequestOptions.externalRequest&lt;/a&gt;
   * @default `false`
   */</span>
  externalRequest?: <span class="hljs-built_in">boolean</span>;

  <span class="hljs-comment">/**
   * If true, then the provider is connected to a socket server
   * @default `false`
   */</span>
  socket?: <span class="hljs-built_in">boolean</span>;
}</code></pre>
						<a href="#registering-a-data-provider-as-multiton" id="registering-a-data-provider-as-multiton" style="color: inherit; text-decoration: none;">
							<h3>Registering a data provider as multiton</h3>
						</a>
						<p>You can register your data provider by a name in the global storage. For that case, you should use the special decorator &quot;provider&quot;.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider, providers } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  baseURL = <span class="hljs-string">'user/:id'</span>;
}

<span class="hljs-built_in">console</span>.log(providers[<span class="hljs-string">'User'</span>]);</code></pre>
						<p>The name to register is taken from the class name of the provider. Also, you can declare a namespace that is concatenated with the name.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider, providers } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider(<span class="hljs-string">'base'</span>)
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  baseURL = <span class="hljs-string">'user/:id'</span>;
}

<span class="hljs-built_in">console</span>.log(providers[<span class="hljs-string">'base.User'</span>]);</code></pre>
						<p>It can be useful to provide data providers to components as input properties:</p>
						<pre><code class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">my-component</span> <span class="hljs-attr">dataProvider</span>=<span class="hljs-string">"base.User"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-component</span>&gt;</span></code></pre>
						<a href="#decorating-a-request-function" id="decorating-a-request-function" style="color: inherit; text-decoration: none;">
							<h3>Decorating a request function</h3>
						</a>
						<a href="#request-methods" id="request-methods" style="color: inherit; text-decoration: none;">
							<h4>Request methods</h4>
						</a>
						<p>The default implementation of a data provider has association between HTTP request methods and the provider methods:</p>
						<pre><code class="language-js">{
  <span class="hljs-comment">/**
   * Default HTTP request method for the "get" method
   */</span>
  <span class="hljs-attr">getMethod</span>: RequestMethod = <span class="hljs-string">'GET'</span>;

  <span class="hljs-comment">/**
   * Default HTTP request method for the "peek" method
   */</span>
  peekMethod: RequestMethod = <span class="hljs-string">'HEAD'</span>;

  <span class="hljs-comment">/**
   * Default HTTP request method for the "add" method
   */</span>
  addMethod: RequestMethod = <span class="hljs-string">'POST'</span>;

  <span class="hljs-comment">/**
   * Default HTTP request method for the "upd" method
   */</span>
  updMethod: RequestMethod = <span class="hljs-string">'PUT'</span>;

  <span class="hljs-comment">/**
   * Default HTTP request method for the "del" method
   */</span>
  delMethod: RequestMethod = <span class="hljs-string">'DELETE'</span>;
}</code></pre>
						<p>You allow to rewrite it in your subclass.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  baseURL = <span class="hljs-string">'user/:id'</span>;
  getMethod = <span class="hljs-string">'POST'</span>;
}</code></pre>
						<a href="#base-url-for-requests" id="base-url-for-requests" style="color: inherit; text-decoration: none;">
							<h4>Base URL for requests</h4>
						</a>
						<p>The base URL is the starting point for URLs of each request. You can provide one universal URL by using <code>baseURL</code> parameter, but also,
						you can specify a base URL for each particular method.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  baseURL = <span class="hljs-string">'user/:id'</span>;
  baseAddURL = <span class="hljs-string">'user/add'</span>;
  baseDeLURL = <span class="hljs-string">'user/:id/del'</span>;
}</code></pre>
						<a href="#url-interpolation" id="url-interpolation" style="color: inherit; text-decoration: none;">
							<h5>URL interpolation</h5>
						</a>
						<p>You can specify dynamically values within a URL string. For this case just add a variable with <code>:</code> character before the name.
							The values for interpolations are taken from a query object or request body (if it&#39;s represented as a simple JS object).
						After interpolation, all values that were used will be dropped from a source object.</p>
						<a href="#middlewares" id="middlewares" style="color: inherit; text-decoration: none;">
							<h4>Middlewares</h4>
						</a>
						<p>Middleware is a simple function that is invoked before each request and can modify some request parameters, like adding/removing HTTP headers, etc.
						The function takes a request environment:</p>
						<pre><code class="language-ts">{
  ctx: RequestContext&lt;T&gt;;
  opts: CreateRequestOptions&lt;T&gt;;
  globalOpts: GlobalOptions;
}</code></pre>
						<p>You can specify a sequence of middlewares to the provider, but notice that the order of middlewares depends on the structure that you use (hash doesn&#39;t preserve the order, but arrays/maps do it).</p>
						<p>For example, we need to add some authorization header for every request of the provider.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> middlewares = {
    addSession({<span class="hljs-attr">opts</span>: {headers}}) {
      headers[<span class="hljs-string">'Authorization'</span>] = <span class="hljs-string">'bearer myJWTToken'</span>;
    }
  };

  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<p>Basically, the result of a middleware function is ignoring, with the exceptions of promises and functions.
							If some middleware returns a promise, it will be awaited.
							If at least one of the middlewares returns a function, then the result of invoking this function will be returned as the request result.
						It can be helpful to organize mocks of data and other similar cases when you don&#39;t want to execute a real request.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider, Response } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> middlewares = {
    attachMocks() {
      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> Response({<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Andrey'</span>}, {
        <span class="hljs-attr">status</span>: <span class="hljs-number">200</span>,
        <span class="hljs-attr">responseType</span>: <span class="hljs-string">'object'</span>
      });
    }
  };

  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<a href="#encoders" id="encoders" style="color: inherit; text-decoration: none;">
							<h4>Encoders</h4>
						</a>
						<p>The encoder is a subtype of a middleware function, but unlike the simple middleware, the encoder must return a value and provide it
							to another encoder or a request, which means that a sequence of encoders are tied with an order of following.
							Encoders are using to convert data to another format before submitting it to a request.
						For example, your server demands that all request data must be represented as a protobuf value.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> encoders = {
    <span class="hljs-attr">upd</span>: [toProtobuf]
  };

  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<p>Note that unlike &quot;middlewares&quot; parameter the encoders are separated between provider methods, which means
						that you should declare encoders for all your method pipelines.</p>
						<p>The encoder function has the signature:</p>
						<pre><code class="language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Encoder&lt;I = unknown, O = unknown&gt; {
  (data: I, params: MiddlewareParams): O;
}</code></pre>
						<p>Where:</p>
						<ol>
							<li><code>data</code> is your data;</li>
							<li><code>params</code> is an environment of your request.</li>
						</ol>
						<p>If some encoder returns a promise, it will be awaited.</p>
						<a href="#decoders" id="decoders" style="color: inherit; text-decoration: none;">
							<h4>Decoders</h4>
						</a>
						<p>The decoder is another subtype of a middleware function, which is pretty similar to &quot;encoder&quot;, but unlike the encoder,
						it converts data from a server to the provider format.</p>
						<p>The decoder function has the signature:</p>
						<pre><code class="language-ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">interface</span> Encoder&lt;I = unknown, O = unknown&gt; {
  (data: I, params: MiddlewareParams, response: Response): O;
}</code></pre>
						<p>The first parameters are equal to the encoder function. The last parameter contains a link to a response object.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> decoders = {
    <span class="hljs-attr">get</span>: [fromProtobuf]
  };

  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<p>If some encoder returns a promise, it will be awaited.</p>
						<a href="#custom-request-function" id="custom-request-function" style="color: inherit; text-decoration: none;">
							<h4>Custom request function</h4>
						</a>
						<p>To create a request all providers use the <code>core/request</code> module. If you need to provide some extra parameters of the request, such as &quot;contentType&quot;, you can specify a factory to make these requests using the special overload of the request function.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'core/request'</span>;
<span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> request = request({
    <span class="hljs-attr">contentType</span>: <span class="hljs-string">'json'</span>,
    <span class="hljs-attr">cacheStrategy</span>: <span class="hljs-string">'forever'</span>,
    <span class="hljs-attr">cacheTTL</span>: (<span class="hljs-number">10</span>).seconds()
  });

  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<a href="#interpolation-of-headers" id="interpolation-of-headers" style="color: inherit; text-decoration: none;">
							<h4>Interpolation of headers</h4>
						</a>
						<p>Headers of a request also have support for interpolation from request data, which similar to &quot;baseURL&quot;.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">'core/request'</span>;
<span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> request = request({
    <span class="hljs-attr">header</span>: {
      <span class="hljs-attr">Accept</span>: <span class="hljs-string">'${accept}'</span>
    }
  });

  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<a href="#providing-an-api-url" id="providing-an-api-url" style="color: inherit; text-decoration: none;">
							<h5>Providing an API URL</h5>
						</a>
						<p>You can specify a base URL for your server. It can be useful if you have different URLs for development, staging, and production.
						The API URL is concatenated with the base URL of a provider.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> request = request({
    <span class="hljs-attr">api</span>: {<span class="hljs-attr">url</span>: <span class="hljs-string">'https://google.com'</span>}
  });

  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<p>The value can also be declared as a function that is invoked at each request.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> request = request({
    <span class="hljs-attr">api</span>: {<span class="hljs-attr">url</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> USE_PROD ? <span class="hljs-string">'https://google.com'</span> : <span class="hljs-string">'https://dev.google.com'</span>}
  });

  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<p>Finally, if you specify the default API URL within <code>core/config/api</code>, you can provide some chunks of an API URL that are applied to the base.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> request = request({
    <span class="hljs-attr">api</span>: {
      <span class="hljs-attr">domain3</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> USE_PROD ? <span class="hljs-string">''</span> : <span class="hljs-string">'dev'</span>,
      <span class="hljs-attr">zone</span>: <span class="hljs-string">'io'</span>
    }
  });

  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<a href="#composition-of-providers" id="composition-of-providers" style="color: inherit; text-decoration: none;">
							<h3>Composition of providers</h3>
						</a>
						<p>You can create a composition of multiple providers that are fetching in parallel and merging to one data. This mechanism is called &quot;extraProviders&quot;. Mind that API work only for a get request.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  extraProviders = <span class="hljs-function">(<span class="hljs-params">{opts: {query}}</span>) =&gt;</span> ({
    <span class="hljs-string">'skills'</span>: {
      <span class="hljs-attr">provider</span>: <span class="hljs-string">'Skills'</span>,
      <span class="hljs-attr">query</span>: {<span class="hljs-attr">id</span>: query.id}
    }
  });

  alias = <span class="hljs-string">'user'</span>;
  baseURL = <span class="hljs-string">'user/:id'</span>;
}

<span class="hljs-keyword">new</span> User().get({<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>}).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
  <span class="hljs-comment">// The main data from User provider is stored by an alias (if it's specified) or by a provider name</span>
  <span class="hljs-built_in">console</span>.log(data.user);

  <span class="hljs-comment">// The extra data is stored by an alias (if it's specified) or by a key name from the declaration</span>
  <span class="hljs-built_in">console</span>.log(data.skills);
});</code></pre>
						<a href="#extra-provider" id="extra-provider" style="color: inherit; text-decoration: none;">
							<h4>Extra provider</h4>
						</a>
						<p>The declaration object of an extra provider has a standard interface:</p>
						<pre><code class="language-ts"><span class="hljs-keyword">type</span> ExtraProviderConstructor =
  <span class="hljs-built_in">string</span> |
  Provider |
  {<span class="hljs-keyword">new</span>(opts?: ProviderOptions): Provider};

<span class="hljs-keyword">interface</span> ExtraProvider {
  provider?: ExtraProviderConstructor;
  providerOptions?: ProviderOptions;
  query?: RequestQuery;
  request?: CreateRequestOptions;
  alias?: <span class="hljs-built_in">string</span>;
}</code></pre>
						<ul>
							<li><code>provider</code> — full name of a provider or a link to the provider or the provider constructor;</li>
							<li><code>providerOptions</code> — additional options for the provider constructor;</li>
							<li><code>query</code> — query parameters for a provider get request;</li>
							<li><code>request</code> — request parameters for the provider;</li>
							<li><code>alias</code> — alias of data: the data is stored by a key from this value in a result object.</li>
						</ul>
						<a href="#static-extra-providers" id="static-extra-providers" style="color: inherit; text-decoration: none;">
							<h4>Static extra providers</h4>
						</a>
						<p>If you don&#39;t need to provide dynamic parameters to a request you can define a static object instead of function.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  extraProviders = {
    <span class="hljs-string">'skills'</span>: {
      <span class="hljs-attr">provider</span>: <span class="hljs-string">'Skills'</span>
    }
  };

  alias = <span class="hljs-string">'user'</span>;
  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<a href="#extending-one-data-provider-from-another-provider" id="extending-one-data-provider-from-another-provider" style="color: inherit; text-decoration: none;">
							<h3>Extending one data provider from another provider</h3>
						</a>
						<p>The data provider is a simple class implements a special interface. That&#39;s why to create a new provider that is extended parameters from another provider you should create a simple subclass.</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> request = request({
    <span class="hljs-attr">api</span>: {<span class="hljs-attr">url</span>: <span class="hljs-string">'https://google.com'</span>}
  });

  <span class="hljs-keyword">static</span> middlewares = {
    addSession({<span class="hljs-attr">opts</span>: {headers}}) {
      headers[<span class="hljs-string">'Authorization'</span>] = <span class="hljs-string">'bearer myJWTToken'</span>;
    }
  };

  baseURL = <span class="hljs-string">'user/:id'</span>;
}

@provider
<span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">User</span> </span>{
  <span class="hljs-keyword">static</span> request = User.request({
    <span class="hljs-attr">contentType</span>: <span class="hljs-string">'json'</span>
  });

  <span class="hljs-keyword">static</span> middlewares = {
    ...User.middlewares,
    addABHeader({<span class="hljs-attr">opts</span>: {headers}}) {
      headers[<span class="hljs-string">'X-AB'</span>] = <span class="hljs-string">'foo'</span>;
    }
  };
}</code></pre>
						<a href="#specifying-data-mocks" id="specifying-data-mocks" style="color: inherit; text-decoration: none;">
							<h3>Specifying data mocks</h3>
						</a>
						<p>There is a standard middleware to organize a mechanism of data mocking — &quot;attackMock&quot; middleware (it is used by default).</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> mocks = {
    <span class="hljs-attr">PUT</span>: [
      {
        <span class="hljs-attr">body</span>: {
          <span class="hljs-attr">age</span>: <span class="hljs-number">31</span>
        },

        <span class="hljs-attr">response</span>: {
          <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
          <span class="hljs-attr">name</span>: <span class="hljs-string">"Andrey"</span>,
          <span class="hljs-attr">age</span>: <span class="hljs-number">31</span>
        }
      }
    ],

    <span class="hljs-attr">GET</span>: [{
      <span class="hljs-attr">response</span>: {
        <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Andrey"</span>,
        <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
      }
    }]
  };

  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<p>Mind that root keys of mocks represent HTTP methods, but not provider methods. The values contain arrays of request objects to match: the algorithm finds the most suitable option and returns its response. Also, the middleware supports dynamically casting responses:</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> mocks = {
    <span class="hljs-attr">GET</span>: [{
      response(params, response) {
        <span class="hljs-keyword">if</span> (!params.opts.query?.id) {
          response.status = <span class="hljs-number">400</span>;
          <span class="hljs-keyword">return</span>;
        }

        response.status = <span class="hljs-number">200</span>;
        <span class="hljs-keyword">return</span> {
          <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,
          <span class="hljs-attr">name</span>: <span class="hljs-string">"Andrey"</span>,
          <span class="hljs-attr">age</span>: <span class="hljs-number">30</span>
        };
       }
    }]
  };

  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<p>Finally, you can use dynamic importing with mocks:</p>
						<pre><code class="language-js"><span class="hljs-keyword">import</span> Provider, { provider } <span class="hljs-keyword">from</span> <span class="hljs-string">'core/provider'</span>;

@provider
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Provider</span> </span>{
  <span class="hljs-keyword">static</span> mocks = <span class="hljs-keyword">import</span>(<span class="hljs-string">'mocks/user.json'</span>);
  baseURL = <span class="hljs-string">'user/:id'</span>;
}</code></pre>
						<a href="#enabling-data-mocks-for-a-provider" id="enabling-data-mocks-for-a-provider" style="color: inherit; text-decoration: none;">
							<h4>Enabling data mocks for a provider</h4>
						</a>
						<p>By default, all data mocks is disabled, but you can enable it just type to a console of a browser:</p>
						<pre><code class="language-js"><span class="hljs-comment">// Enables mocks for the User provider</span>
setEnv(<span class="hljs-string">'mock'</span>, {<span class="hljs-attr">patterns</span>: [<span class="hljs-string">'User'</span>]});

<span class="hljs-comment">// Enables mocks for all providers</span>
setEnv(<span class="hljs-string">'mock'</span>, {<span class="hljs-attr">patterns</span>: [<span class="hljs-string">'.*'</span>]});</code></pre>
						<p>The values of patterns are converted to RegExp objects and applied to provider names (including namespaces).
						Config settings are stored within a browser local storage.</p>
					</div>
				</div>
			</section>
			<section class="tsd-panel-group tsd-index-group">
				<h2>Index</h2>
				<section class="tsd-panel tsd-index-panel">
					<div class="tsd-index-content">
						<section class="tsd-index-section ">
							<h3>Classes</h3>
							<ul class="tsd-index-list">
								<li class="tsd-kind-class tsd-parent-kind-external-module"><a href="../classes/src_core_data_index.provider.html" class="tsd-kind-icon">Provider</a></li>
							</ul>
						</section>
					</div>
				</section>
			</section>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="../globals.html"><em>Globals</em></a>
					</li>
					<li class="current tsd-kind-external-module">
						<a href="src_core_data_index.html">&quot;src/core/data/index&quot;</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
					<li class=" tsd-kind-class tsd-parent-kind-external-module">
						<a href="../classes/src_core_data_index.provider.html" class="tsd-kind-icon">Provider</a>
					</li>
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer>
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-module"><span class="tsd-kind-icon">Module</span></li>
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-variable"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-function"><span class="tsd-kind-icon">Function</span></li>
				<li class="tsd-kind-function tsd-has-type-parameter"><span class="tsd-kind-icon">Function with type parameter</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
				<li class="tsd-kind-type-alias"><span class="tsd-kind-icon">Type alias</span></li>
				<li class="tsd-kind-type-alias tsd-has-type-parameter"><span class="tsd-kind-icon">Type alias with type parameter</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
				<li class="tsd-kind-property tsd-parent-kind-enum"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-enum"><span class="tsd-kind-icon">Method</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-interface tsd-has-type-parameter"><span class="tsd-kind-icon">Interface with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-interface"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-class tsd-has-type-parameter"><span class="tsd-kind-icon">Class with type parameter</span></li>
				<li class="tsd-kind-constructor tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class"><span class="tsd-kind-icon">Method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class"><span class="tsd-kind-icon">Accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-constructor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-protected"><span class="tsd-kind-icon">Protected accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-method tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private method</span></li>
				<li class="tsd-kind-accessor tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private accessor</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static method</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="overlay"></div>
<script src="../assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="../assets/js/search.js"><' + '/script>');</script>
<script>'use strict';

/*!
 * V4Fire Core
 * https://github.com/V4Fire/Core
 *
 * Released under the MIT license
 * https://github.com/V4Fire/Core/blob/master/LICENSE
 */

/* eslint-disable prefer-arrow-callback, no-var */

(function () {
	document.body.style.display = 'block';

	var
		isDTS = /([^/.]+)\.d/,
		isIndex = /\/index|\.d/,
		isNode = /(?:^|\b)node_modules(?:\b|$)/;

	var
		trimRgxp = /^\s+|[\n\v"']+|\s+$/g,
		normalizeRgxp = /(?:^|\b)src\//;

	var
		breadcrumbs = Array.from(document.querySelectorAll('.tsd-breadcrumb a')),
		headers = Array.from(document.querySelectorAll('h1'));

	breadcrumbs.forEach(function (el) {
		el.textContent = el.textContent.replace(trimRgxp, '').replace(normalizeRgxp, '');
	});

	headers.forEach(function (el) {
		el.textContent = el.textContent.replace(trimRgxp, '').replace(normalizeRgxp, '');
	});

	var
		navigation = Array.from(document.querySelectorAll('.tsd-navigation.primary .tsd-kind-external-module a')),
		globalIndex = Array.from(document.querySelectorAll('.tsd-index-list a'));

	[].concat(navigation, breadcrumbs.length <= 1 ? globalIndex : []).forEach(function (el) {
		var
			wrapper = el.parentNode,
			linkText = el.textContent.replace(trimRgxp, '');

		if (isIndex.test(linkText)) {
			if (isDTS.test(linkText)) {
				var
					nm = RegExp.$1;

				if (linkText === 'index.d') {
					el.innerHTML = '<b>prelude</b>';

				} else if (isNode.test(linkText)) {
					el.textContent = nm;

				} else {
					wrapper.parentNode.removeChild(wrapper);
				}

			} else {
				el.textContent = linkText.replace(isIndex, '').replace(normalizeRgxp, '');
			}

		} else {
			wrapper.parentNode.removeChild(wrapper);
		}
	});
})();
</script>
</body>
</html>